#
#  __init__.py
#  Pool Controller
#
#  Generated by Gemini AI Pro 2.5 -- 9/30/2025
#
import esphome.codegen as cg
import esphome.config_validation as cv
from esphome.components import sensor, uart
from esphome.const import (
    CONF_ID,
    CONF_FLOW,
    CONF_POWER,
    CONF_RPM,
    DEVICE_CLASS_CURRENT,
    DEVICE_CLASS_DURATION,
    DEVICE_CLASS_POWER,
    ICON_CURRENT_AC,
    ICON_GAUGE,
    ICON_PERCENT,
    ICON_POWER,
    ICON_ROTATE_RIGHT,
    ICON_TIMER,
    STATE_CLASS_MEASUREMENT,
    STATE_CLASS_TOTAL_INCREASING,
    UNIT_AMPERE,
    UNIT_CELSIUS,
    UNIT_EMPTY,
    UNIT_GALLONS_PER_MINUTE,
    UNIT_HOUR,
    UNIT_PERCENT,
    UNIT_REVOLUTIONS_PER_MINUTE,
    UNIT_WATT,
)

# Define a C++ namespace for this component
pool_pump_rs485_ns = cg.esphome_ns.namespace("pool_pump_rs485")

# Create a Python handle for the C++ class
PoolPumpRS485 = pool_pump_rs485_ns.class_(
    "PoolPumpRS485", cg.Component, uart.UARTDevice
)

# Define constants for our custom YAML configuration keys to avoid magic strings
CONF_WATTS = "watts"
CONF_RUN_TIME = "run_time"
CONF_TARGET_RUN_HOURS = "target_run_hours"
CONF_RUN_HOURS_DEFICIT = "run_hours_deficit"


# Define the YAML configuration schema for the component.
# This tells ESPHome what keys are allowed in the YAML and how to validate them.
CONFIG_SCHEMA = (
    cv.Schema(
        {
            # The main component requires an ID so it can be referenced.
            cv.GenerateID(): cv.declare_id(PoolPumpRS485),
            
            # Define the seven optional sensor sub-schemas.
            # The keys here (CONF_RPM, CONF_WATTS, etc.) are what the user
            # will put in their YAML configuration.
            cv.Optional(CONF_RPM): sensor.sensor_schema(
                unit_of_measurement=UNIT_REVOLUTIONS_PER_MINUTE,
                icon=ICON_ROTATE_RIGHT,
                accuracy_decimals=0,
                state_class=STATE_CLASS_MEASUREMENT,
            ),
            cv.Optional(CONF_WATTS): sensor.sensor_schema(
                unit_of_measurement=UNIT_WATT,
                icon=ICON_POWER,
                accuracy_decimals=0,
                device_class=DEVICE_CLASS_POWER,
                state_class=STATE_CLASS_MEASUREMENT,
            ),
            cv.Optional(CONF_FLOW): sensor.sensor_schema(
                unit_of_measurement=UNIT_GALLONS_PER_MINUTE,
                icon="mdi:water-pump",
                accuracy_decimals=0,
                state_class=STATE_CLASS_MEASUREMENT,
            ),
            cv.Optional(CONF_POWER): sensor.sensor_schema(
                unit_of_measurement=UNIT_PERCENT,
                icon=ICON_PERCENT,
                accuracy_decimals=0,
                state_class=STATE_CLASS_MEASUREMENT,
            ),
            cv.Optional(CONF_RUN_TIME): sensor.sensor_schema(
                unit_of_measurement=UNIT_HOUR,
                icon=ICON_TIMER,
                accuracy_decimals=2,
                device_class=DEVICE_CLASS_DURATION,
                state_class=STATE_CLASS_TOTAL_INCREASING,
            ),
            cv.Optional(CONF_TARGET_RUN_HOURS): sensor.sensor_schema(
                unit_of_measurement=UNIT_HOUR,
                icon="mdi:bullseye-arrow",
                accuracy_decimals=2,
                device_class=DEVICE_CLASS_DURATION,
            ),
            cv.Optional(CONF_RUN_HOURS_DEFICIT): sensor.sensor_schema(
                unit_of_measurement=UNIT_HOUR,
                icon="mdi:timer-sand-paused",
                accuracy_decimals=2,
                device_class=DEVICE_CLASS_DURATION,
            ),
        }
    )
    .extend(cv.COMPONENT_SCHEMA)
    .extend(uart.UART_DEVICE_SCHEMA) # Inherit schema from UARTDevice (requires uart_id)
)

# This function is called by ESPHome to generate the C++ code
async def to_code(config):
    """Generate C++ code for this component."""
    
    # Get the UART bus component instance
    uart_component = await cg.get_variable(config[uart.CONF_UART_ID])

    # Create a new C++ instance of our PoolPumpRS485 class, passing the UART bus
    var = cg.new_Pvariable(config[CONF_ID], uart_component)
    
    # Register this instance as a Component
    await cg.register_component(var, config)

    # Process each of the seven sensor configurations.
    # If a sensor is defined in the YAML, create it and link it to the main component
    # by calling the corresponding C++ setter method.
    if rpm_config := config.get(CONF_RPM):
        sens = await sensor.new_sensor(rpm_config)
        cg.add(var.set_rpm_sensor(sens))

    if watts_config := config.get(CONF_WATTS):
        sens = await sensor.new_sensor(watts_config)
        cg.add(var.set_watts_sensor(sens))

    if flow_config := config.get(CONF_FLOW):
        sens = await sensor.new_sensor(flow_config)
        cg.add(var.set_flow_sensor(sens))

    if power_config := config.get(CONF_POWER):
        sens = await sensor.new_sensor(power_config)
        cg.add(var.set_power_sensor(sens))

    if run_time_config := config.get(CONF_RUN_TIME):
        sens = await sensor.new_sensor(run_time_config)
        cg.add(var.set_run_time_sensor(sens))

    if target_run_hours_config := config.get(CONF_TARGET_RUN_HOURS):
        sens = await sensor.new_sensor(target_run_hours_config)
        cg.add(var.set_target_run_hours_sensor(sens))
        
    if run_hours_deficit_config := config.get(CONF_RUN_HOURS_DEFICIT):
        sens = await sensor.new_sensor(run_hours_deficit_config)
        cg.add(var.set_run_hours_deficit_sensor(sens))
