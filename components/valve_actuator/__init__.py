#
#  __init__.py
#  Pool Controller
#
#  Generated by Gemini AI 2.5 Pro on 2025-09-30.
#

import esphome.codegen as cg
import esphome.config_validation as cv
from esphome.components import sensor, text_sensor
from esphome.const import (
    CONF_ID,
    STATE_CLASS_MEASUREMENT,
    UNIT_AMPERE,
    UNIT_SECOND,
    ICON_CURRENT_AC,
    ICON_TIMER,
    ICON_VALVE,
)

# Define a namespace for your C++ code to avoid naming conflicts
valve_actuator_ns = cg.esphome_ns.namespace("ValveActuator")
# Get a handle to your C++ class, specifying it's a Component
ValveActuator = valve_actuator_ns.class_("ValveActuator", cg.Component)

# Define the names for the configuration options in the user's YAML file
CONF_PEAK_CURRENT = "peak_current"
CONF_ACTUATION_TIME = "actuation_time"
CONF_VALVE_POSITION = "valve_position"

# This CONFIG_SCHEMA defines what is allowed in the user's YAML configuration.
CONFIG_SCHEMA = cv.Schema(
    {
        # Generate a C++ ID for the component. This is how we'll refer to it.
        cv.GenerateID(): cv.declare_id(ValveActuator),
        
        # Define the 'peak_current' sensor. It's optional.
        cv.Optional(CONF_PEAK_CURRENT): sensor.sensor_schema(
            unit_of_measurement=UNIT_AMPERE,
            icon=ICON_CURRENT_AC,
            accuracy_decimals=2,
            state_class=STATE_CLASS_MEASUREMENT,
        ),
        
        # Define the 'actuation_time' sensor. It's optional.
        cv.Optional(CONF_ACTUATION_TIME): sensor.sensor_schema(
            unit_of_measurement=UNIT_SECOND,
            icon=ICON_TIMER,
            accuracy_decimals=1,
            state_class=STATE_CLASS_MEASUREMENT,
        ),

        # Define the 'valve_position' text sensor. It's optional.
        cv.Optional(CONF_VALVE_POSITION): text_sensor.text_sensor_schema(
            icon=ICON_VALVE,
        ),
    }
).extend(cv.COMPONENT_SCHEMA)


# This function runs to generate the final C++ code.
async def to_code(config):
    # This is the special part for a singleton. Instead of `new ValveActuator()`,
    # we generate code that calls your `getInstance()` method.
    var = cg.variable(config[CONF_ID], ValveActuator.getInstance())
    
    # Register the component with ESPHome's application hub
    await cg.register_component(var, config)

    # If the user configured a 'peak_current' sensor in their YAML...
    if CONF_PEAK_CURRENT in config:
        # ...create a new C++ sensor object with the user's config...
        sens = await sensor.new_sensor(config[CONF_PEAK_CURRENT])
        # ...and generate C++ code to call the public setter to link them.
        cg.add(var.set_peakCurrentSensor(sens))

    # Repeat the process for the actuation time sensor
    if CONF_ACTUATION_TIME in config:
        sens = await sensor.new_sensor(config[CONF_ACTUATION_TIME])
        cg.add(var.set_actuationTimeSensor(sens))

    # Repeat the process for the valve position text sensor
    if CONF_VALVE_POSITION in config:
        sens = await text_sensor.new_text_sensor(config[CONF_VALVE_POSITION])
        cg.add(var.set_valvePositionSensor(sens))
