#
#  __init__.py
#  Pool Controller
#
#  Generated by Gemini AI Pro 2.5 -- 9/30/2025
#
"""Component to estimate water temperature when direct readings are unavailable."""

import esphome.codegen as cg
import esphome.config_validation as cv
from esphome.components import sensor
from esphome.const import (
    CONF_ID,
    CONF_VALUE,
    UNIT_CELSIUS,
    ICON_THERMOMETER,
    DEVICE_CLASS_TEMPERATURE,
    STATE_CLASS_MEASUREMENT,
)
from esphome.automation import ACTION_REGISTRY

# It's good practice to list the author of the C++ code here
CODEOWNERS = ['@garymorris']

# Declare the C++ class from your header file for the code generator.
TemperatureEstimator = cg.global_ns.class_("TemperatureEstimator", cg.PollingComponent)

# Define the configuration schema for the sensor platform.
PLATFORM_SCHEMA = (
    sensor.sensor_schema(
        unit_of_measurement=UNIT_CELSIUS,
        icon=ICON_THERMOMETER,
        accuracy_decimals=1,
        device_class=DEVICE_CLASS_TEMPERATURE,
        state_class=STATE_CLASS_MEASUREMENT,
    )
    .extend(
        {
            # This generates a unique ID for the TemperatureEstimator C++ object.
            # This ID is used to reference the component in actions.
            cv.GenerateID(): cv.declare_id(TemperatureEstimator),
        }
    )
    .extend(cv.polling_component_schema)
)

async def to_code(config):
    """
    Code generation function for this component.
    This will be called by ESPHome to generate the C++ code.
    """
    # Get the singleton instance of the TemperatureEstimator class.
    # The 'config[CONF_ID]' is the ID the user provides for this sensor in YAML.
    # We are associating that ID with the singleton instance.
    var = cg.variable(config[CONF_ID], cg.RawExpression("TemperatureEstimator::getInstance()"))

    # Register this as a PollingComponent, which will handle the update() calls.
    await cg.register_component(var, config)
    
    # Create a new Sensor object from the user's YAML configuration.
    sens = await sensor.new_sensor(config)

    # Use the public setter to link the sensor created by the framework
    # to your C++ component instance.
    # C++ equivalent: `var->set_estimatedTempSensor(sens);`
    cg.add(var.set_estimatedTempSensor(sens))


# --- Actions ---
# This section defines actions that can be used in automations.

# Schema for the 'set_panel_temp' action
SET_PANEL_TEMP_ACTION_SCHEMA = cv.Schema(
    {
        # The ID of the temp_estimator sensor component.
        cv.Required(CONF_ID): cv.use_id(TemperatureEstimator),
        # The value to set, which can be a template.
        cv.Required(CONF_VALUE): cv.templatable(cv.float_),
    }
)

@ACTION_REGISTRY.register(
    "temp_estimator.set_panel_temp", SET_PANEL_TEMP_ACTION_SCHEMA
)
async def set_panel_temp_action_to_code(config, action_id, template_arg, args):
    """Code generation for the 'set_panel_temp' action."""
    paren = await cg.get_variable(config[CONF_ID])
    value = await cg.templatable(config[CONF_VALUE], args, float)
    return paren.setPanelTempC(value)


# Schema for the 'set_water_temp' action
SET_WATER_TEMP_ACTION_SCHEMA = cv.Schema(
    {
        # The ID of the temp_estimator sensor component.
        cv.Required(CONF_ID): cv.use_id(TemperatureEstimator),
        # The value to set, which can be a template.
        cv.Required(CONF_VALUE): cv.templatable(cv.float_),
    }
)

@ACTION_REGISTRY.register(
    "temp_estimator.set_water_temp", SET_WATER_TEMP_ACTION_SCHEMA
)
async def set_water_temp_action_to_code(config, action_id, template_arg, args):
    """Code generation for the 'set_water_temp' action."""
    paren = await cg.get_variable(config[CONF_ID])
    value = await cg.templatable(config[CONF_VALUE], args, float)
    return paren.setWaterTempC(value)
