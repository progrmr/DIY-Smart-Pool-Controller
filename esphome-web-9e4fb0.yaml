substitutions:
  devicename: esphome-pool-controller
  friendly_devicename: "ESPHome Pool Controller"
  deviceip: 192.168.0.229

esphome:
  name: ${devicename}
  friendly_name: ${friendly_devicename}
  includes:
    - solar_controller.h
    - valve_actuator.h
    - pool_pump_rs485.h
  on_boot:
    priority: -10
    then:
      - delay: 10s
      - lambda: |-
          //---------------------
          // need to call requestPumpSpeed after reboot in case we
          // are requesting a particular pump speed.  The C++ class gets
          // reinitialized when booting and we need to restore the speed.
          //---------------------
          auto pumpSpeedRequest = id(pump_speed_request)->state;
          if (!std::isnan(pumpSpeedRequest)) {
            long speed = lroundf(pumpSpeedRequest);
            ESP_LOGD("custom","===== BOOT: restoring requestPumpSpeed RPM %ld", speed);
            PoolPumpRS485::instance->requestPumpSpeed(speed);
          }
      - delay: 5s
      - lambda: |-
          //---------------------
          // need to init various sensors, they don't get
          // restored after a reboot
          //---------------------
          ESP_LOGD("custom","===== BOOT: restoring min/max water temps, amps/peak");
          float curTemp = id(water_temperature).state;
          id(minimum_water_temperature)->publish_state(curTemp);
          id(maximum_water_temperature)->publish_state(curTemp);
          id(valve_actuator_amps)->publish_state(0);
          id(peak_current)->publish_state(0);
          id(actuation_time)->publish_state(0);
      - delay: 15s
      - lambda: |-
          uint32_t notConnectedCount = 0;
          while (!WiFi.isConnected()) {
            delay(100);   // delay 100 ms
            notConnectedCount++;
            if (notConnectedCount > 300) {   // reset board if not connected after 30s
              ESP.restart();
            }
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "MlixHoYywbRk7gFoWjevidw9EjKcaUDVhOz1a1xSjv0="

ota:

wifi:
  networks:
  - ssid: !secret wifi_ssid
    password: !secret wifi_password

  # Optional manual IP
  manual_ip:
    static_ip: ${deviceip}
    gateway: 192.168.0.1
    subnet: 255.255.255.0
    dns1: 192.168.0.1

#----------------------------------------------------------------------
# UART is used for RS-485 serial comm with the Pentair Pool Pump
# the PoolPumpRS485 custom component class handles the actual
# sending and receiving messages via the RS-485 serial port.
#----------------------------------------------------------------------
uart:
  id: pump_uart_bus
  tx_pin: GPIO14
  rx_pin: GPIO27
  baud_rate: 9600

#----------------------------------------------------------------------
# CURRENT LIMIT
# Current Limit is used to detect problems with the valve actuator.  
# Not Implemented Yet: when current exceeds this limit we should 
# turn the valve actuator off and report an fault.
# https://esphome.io/components/number/template
#----------------------------------------------------------------------
number:
  - platform: template
    name: "Current Limit"
    id: current_limit
    optimistic: True
    restore_value: True
    max_value: 2.0
    min_value: 0.1
    step: 0.1
    initial_value: 0.7
    device_class: "current"
    mode: box
    # do something with the limit, when actual current exceeds limit
    # NOTE: automation in HA detects over limit and sends notifications

#----------------------------------------------------------------------
# PUMP SPEED REQUEST
# This is a temporary solution to commanding the pump toa higher RPM
# when the solar valve is on, the higher RPM is needed to efficiently 
# circulate water through the solar panels on the roof.  The RPM is 
# set in the pump itself in one of the external programs put in via
# the pump's keypad.  See pump's user manual for details.
#
# 1. Set speed 2701 to command external program which runs at 2700 RPM
# 2. Set speed 2401 to command NOT using external program (reverts to normal)
# 3. Set speed to any other value to stop sending commands (pump reverts to normal after ~60 sec)
#
# https://esphome.io/components/number/template
#----------------------------------------------------------------------
  - platform: template
    name: "Pump Speed Request"
    id: pump_speed_request
    optimistic: True
    restore_value: True
    unit_of_measurement: RPM
    device_class: speed
    mode: box
    max_value: 4000
    min_value: 0
    step: 10
    initial_value: 0
    set_action:
      - lambda: |-
          const long speed = lroundf(x);
          ESP_LOGD("custom","===== set new requestPumpSpeed RPM: %ld", speed);
          PoolPumpRS485::instance->requestPumpSpeed(speed);

#----------------------------------------------------------------------
# POOL TARGET TEMPERATURE
# This is for display so the pool users can set their desired pool
# water temperature.  It is used by the solar controller to decide
# how long to run the solar heat and get to this target.
# https://esphome.io/components/number/template
#----------------------------------------------------------------------
  - platform: template
    name: "Pool Target Temperature"
    id: pool_target_temp
    optimistic: True
    restore_value: True
    unit_of_measurement: "°F"
    device_class: temperature
    mode: box
    min_value: 60
    max_value: 95
    step: 1
    initial_value: 86.6

#----------------------------------------------------------------------
# SPA TARGET TEMPERATURE
# This is for display so the spa users can set their desired spa
# water temperature.  It is used by the solar controller to decide
# how long to run the solar heat and get to this target.
# https://esphome.io/components/number/template
#----------------------------------------------------------------------
  - platform: template
    name: "Spa Target Temperature"
    id: spa_target_temp
    optimistic: True
    restore_value: True
    unit_of_measurement: "°F"
    device_class: temperature
    mode: box
    min_value: 90
    max_value: 105
    step: 1
    initial_value: 100

#----------------------------------------------------------------------
# VALVE POSITION (SOLAR)
#
# Valve Position can be:  unknown, opening, closing, opened, closed
# It is initially unknown, but changes based on the relay states etc.
# It is set inside the ValvePosition class.
#
# https://esphome.io/components/text_sensor/custom.html
#----------------------------------------------------------------------
text_sensor:
  - platform: custom
    lambda: |-
      auto vp = new ValvePosition();
      ValvePosition::instance = vp;
      App.register_component(vp);
      return {vp};
    text_sensors:
      name: "Valve Position"  
      id: valve_position
      on_value:
        then:
          - lambda: 'SolarController::instance->setValvePosition(x);'

#----------------------------------------------------------------------
# SOLAR CONTROLLER
#
# Determines if we should be running water through the solar panels.
# The binary output is true if we should be using solar.  It checks
# conditions periodically and updates its decision.  It decides based
# on water temp, panel temp, target temp, pump RPM, and 
# time since last valve position change.  It is designed to have
# hysteresis so that the valve position is not changing back and forth
# every couple minutes, which would wear it out.  For example: it will
# hold its current binary state if the valve position has changed  
# within past 5 minutes.
# https://esphome.io/components/binary_sensor/custom.html
#----------------------------------------------------------------------
binary_sensor:
  - platform: custom
    lambda: |-
      auto sc = new SolarController();
      SolarController::instance = sc;
      App.register_component(sc);
      return {sc};
    binary_sensors:
      - name: "Use Solar Heat"
        id: use_solar_heat
        on_press:
          - lambda: 'ESP_LOGD("custom","^^^^^^^^^^^^^^^ Solar Heat ON ^^^^^^^^^^^^^^^");'
          # bring pump to to speed, wait a bit, then turn valve to solar
          - number.set:
              id: pump_speed_request
              value: 2701
          - delay: 30s
          # set valve to the solar (open) position
          # valve_direction_relay on, opens the valve
          - switch.turn_on: valve_direction_relay
        on_release:
          - lambda: 'ESP_LOGD("custom","vvvvvvvvvvvvvvv Solar Heat OFF vvvvvvvvvvvvvvv");'
          # set pump back to normal speed
          - number.set:
              id: pump_speed_request
              value: 2401
          - delay: 30s
          # set valve back to normal (closed) position
          # valve_power_relay on, with valve_direction_relay off, closes the valve
          - switch.turn_off: valve_direction_relay
          - switch.turn_on: valve_power_relay
          - delay: 60s
          - number.set: 
              id: pump_speed_request
              value: 999 

#----------------------------------------------------------------------
# PEAK CURRENT - keeps track of the valve actuator's peak currant usage
# measured in amps. This is for diagnostic purposes.
# https://esphome.io/components/sensor/custom.html
#----------------------------------------------------------------------
sensor:
  - platform: custom
    lambda: |-
      auto pc = new PeakCurrent();
      PeakCurrent::instance = pc;
      App.register_component(pc);
      return {pc};
    sensors:
      - name: "Peak Current"
        id: peak_current
        accuracy_decimals: 3
        unit_of_measurement: A
        device_class: "current"
        state_class: "measurement"

#----------------------------------------------------------------------
# ACTUATOR TIME
#
# Measures how long it takes for the valve actuator to 
# complete its actuation from open to closed or closed to open.  
# This is for diagnostic purposes.  Taking less than ~26 seconds means
# the valve wasn't fully open/closed, taking longer could mean there
# is a problem with turning the valve.  See also actuator current.
#
# https://esphome.io/components/sensor/custom.html
#----------------------------------------------------------------------
  - platform: custom
    lambda: |-
      auto at = new ActuationTime();
      ActuationTime::instance = at;
      App.register_component(at);
      return {at};
    sensors:
      - name: "Actuation Time"
        id: actuation_time
        accuracy_decimals: 1
        unit_of_measurement: s
        device_class: "duration"
        state_class: "total_increasing"

#----------------------------------------------------------------------
# POOL PUMP RS-485 COMM
#
# This custom C++ class handles serial communications with the pump.  
# Gets the pump status and tells it when to speed up or slow down for 
# solar heating.  Status messages have RPM and Wattage usage which appear 
# in sensors here.  RPM is used to determine when the pump is actually 
# running.  Wattage is for diagnostic/info only.
#
# This class automatically polls the pump for status every 15 seconds.  
# It can also sends commands to set pump speed every 15 seconds. The
# pump reverts to preprogrammed schedule or speed if we stop sending
# the speed commands for longer than 30 seconds or so.
# 
# Pump Run Hours - today's total hours where pump RPM > 1000 RPM
# 
# https://esphome.io/components/sensor/custom.html
#----------------------------------------------------------------------
  - platform: custom
    lambda: |-
      auto myPoolPump = new PoolPumpRS485(id(pump_uart_bus));
      PoolPumpRS485::instance = myPoolPump;   // save singleton instance
      App.register_component(myPoolPump);
      return {myPoolPump->rpmSensor, 
              myPoolPump->wattsSensor, 
              myPoolPump->runTimeSensor}; 
    sensors:
      - name: "RPM Sensor"
        id: pump_rpm_sensor
        unit_of_measurement: RPM
        device_class: "speed"
        state_class: "measurement"
      - name: "Watts Sensor"
        id: pump_watts_sensor
        accuracy_decimals: 0
        unit_of_measurement: W
        device_class: "power"
        state_class: "measurement"
      - name: "Pump Run Hours"
        id: pump_run_hours
        accuracy_decimals: 4
        state_class: "measurement"
        unit_of_measurement: h

#----------------------------------------------------------------------
# SOLAR PANEL TEMPERATURE
#
# Solar Panel Thermistor sensor is located on the roof solar panels and
# is used to determine if it is hot enough to heat the pool water.
# https://esphome.io/components/sensor/ntc
#----------------------------------------------------------------------
  - platform: ntc
    name: Panel Temperature
    id: panel_temperature
    sensor: panel_thermistor
    calibration:
      - 15310Ohm -> 16°C
      - 10000Ohm -> 25°C
      - 3602Ohm -> 50°C
    filters:
      - offset: 0.6
      - sliding_window_moving_average:
          window_size: 5
          send_every: 5

#----------------------------------------------------------------------
# WATER TEMPERATURE NTC
#
# Water Temperature NTC sensor is located in a pipe right next to the pump
# output and it used to measure pool water temperature.  This temperature 
# reading is NOT valid if the pump is off since water is not flowing 
# through the pipe and can cool off or heat up while sitting in the pipe.
# Better to use skimmer water temperature if pump is not running.
# This temperature is used to update the min/max temperatures above.
# https://esphome.io/components/sensor/ntc
#----------------------------------------------------------------------
  - platform: ntc
    name: Water Temperature
    id: water_temperature
    sensor: water_thermistor
    calibration:
      - 15310Ohm -> 16°C
      - 10000Ohm -> 25°C
      - 3602Ohm -> 50°C
    on_value:
      lambda: |-
        if (!std::isnan(x)) {
            auto minTemp = id(minimum_water_temperature);
            if (std::isnan(minTemp->state) || x < minTemp->state) {
              // publish a new minimum water temperature
              minTemp->publish_state(x);
            }
            auto maxTemp = id(maximum_water_temperature);
            if (std::isnan(maxTemp->state) || x > maxTemp->state) {
              // publish a new maximum water temperature
              maxTemp->publish_state(x);
            }
        }
    filters:
      - lambda: |-
          if (PoolPumpRS485::instance->isPipeTempValid()) {
            return x + 0.11;    // add 0.11 based on calibration check
          } else {
            return NAN;   // ignore reading, water not flowing in pipe
          }
      - sliding_window_moving_average:
          window_size: 5
          send_every: 5

# Water Temp Daily Minimum/Maximum sensor
# https://esphome.io/components/sensor/template.html
  - platform: template
    name: Minimum Water Temperature
    id: minimum_water_temperature
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    # NOTE: updates are done elsewhere:
    # (1) midnight (resets min from current) in the time sntp above, 
    # (2) whenever the water_temperature sensor updates.
    update_interval: never

  - platform: template
    name: Maximum Water Temperature
    id: maximum_water_temperature
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    # NOTE: updates are done elsewhere:
    # (1) midnight (resets min from current) in the time sntp above, 
    # (2) whenever the water_temperature sensor updates.
    update_interval: never

#----------------------------------------------------------------------
# RESISTANCE SENSORS for thermistor's voltage dividors
#
# Uses the ADC voltage reading to compute resistance value of the 
# corresponding thermistors.  This value is used above to compute
# a temperature reading from the thermistors.
# https://esphome.io/components/sensor/resistance
#----------------------------------------------------------------------
  - platform: resistance
    internal: True
    id: panel_thermistor
    sensor: panel_thermistor_adc
    configuration: DOWNSTREAM
    resistor: 5.6kOhm
    name: Panel Resistance Sensor
    reference_voltage: 3.3V
    
  - platform: resistance
    internal: True
    id: water_thermistor
    sensor: water_thermistor_adc
    configuration: DOWNSTREAM
    resistor: 5.6kOhm
    name: Water Resistance Sensor
    reference_voltage: 3.3V

#----------------------------------------------------------------------
# ADC SENSORS FOR THERMISTORS
#
# Uses the ADC to measure voltage across thermister voltage dividers.
# One to measure water temperature and one for solar panel temp.
# https://esphome.io/components/sensor/adc
#----------------------------------------------------------------------
  - platform: adc
    internal: True
    id: panel_thermistor_adc
    pin: GPIO33
    name: Panel Thermistor ADC
    update_interval: 61s    
    attenuation: 11db
    filters:
      - offset: -0.02

  - platform: adc
    internal: True
    id: water_thermistor_adc
    pin: GPIO32
    name: Water Thermistor ADC
    update_interval: 59s    
    attenuation: 11db
    filters:
      - offset: -0.02

#----------------------------------------------------------------------
# VALVE ACTUATOR CURRENT SENSOR
#
# The Valve Actuator Current sensor measures peak voltage across a shunt
# resistor (1 ohm) from an AC sine wave (after half wave rectifier), 
# We measure peak voltage(amps) by charging a 10uF capacitor after the
# rectifier which holds at the peak voltage.  There is a 22k resistor
# on the capacitor so that the voltage reading will decay when
# the actual current drops.  See schematic and design manual for details.
# https://esphome.io/components/sensor/adc
#----------------------------------------------------------------------
  - platform: adc
    pin: GPIO36
    name: "Valve Actuator Current"
    id: valve_actuator_amps
    unit_of_measurement: A
    accuracy_decimals: 3
    attenuation: 6db
# NOTE: update_interval of never here, but we manually update every 2-3s when
#       the actuator power is on, if power is off, current *should* be zero.
    update_interval: never  
    filters:
      - lambda: |-
          // if x < 0.15 then current is really 0, it reads 0.15 because
          // the ADC has a minimum voltage that it reads and shows that value
          // even when there is no current flowing (and actual voltage is 0)
          // NOTE: multiply by 0.707 to convert peak to RMS value, add 
          // another 0.095 to calibrate based on 10/7/23 calibration test.
          if (x < 0.15) { return 0.0; } else { return (x * 0.707) + 0.095; }     
    on_value:
      - lambda: |-
          ValvePosition::instance->setCurrent(x);

  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    entity_category: "diagnostic"
    update_interval: 120s
  
  - platform: internal_temperature
    name: "Internal Temperature"
    entity_category: "diagnostic"

#----------------------------------------------------------------------
# The two relays are used to send 24 VAC power to the valve actuator.
#
# You only need to turn on one of the relays in order to open or close
# the valve. The automations below handle the details including turning
# the relays off when done.
#   1. Turn on the valve_direction_relay to open the valve.
#   2. Turn on the valve_power_relay to close the valve.
#
# VALVE POWER RELAY:
#    * when ON provide 24 VAC power to the valve actuator, valve will
#      not change direction or move at all unless this is on.
#
# VALVE DIRECTION RELAY:
#    * when ON turns the valve to send water through the solar panels,
#    * when OFF valve turns back to normal (bypass solar) position
#
# NOTE: valve actuation takes about 26 seconds to complete, 
#       actuator current drops to 0 when it finishes moving
#
# https://esphome.io/components/switch/gpio.html
# https://devices.esphome.io/devices/Generic-Relay
#----------------------------------------------------------------------
switch:
  - platform: gpio
    name: "Valve Power Relay"
    id: valve_power_relay
    inverted: True
    pin: GPIO23  
    on_turn_on:
      then:
        - lambda: |-
            ValvePosition::instance->setValvePowerRelayOn(true);
        - repeat:
            count: 32
            then:
              - delay: 0.5s
              - component.update: valve_actuator_amps
              - delay: 0.5s
        - switch.turn_off: valve_power_relay
    on_turn_off:
      then:
        - lambda: |-
            ValvePosition::instance->setValvePowerRelayOn(false);

  - platform: gpio
    name: "Valve Direction Relay"
    id: valve_direction_relay
    inverted: True
    pin: GPIO22
    on_turn_on:
      then:
        - lambda: |-
            ValvePosition::instance->setValveDirectionRelayOn(true);
        - switch.turn_on: valve_power_relay
        - delay: 30s
        - switch.turn_off: valve_power_relay
        - switch.turn_off: valve_direction_relay
    on_turn_off:
      then:
        - lambda: |-
            ValvePosition::instance->setValveDirectionRelayOn(false);
        
  - platform: template
    name: "Spa Mode"
    id: spa_mode
    optimistic: True
    
#----------------------------------------------------------------------
# TIME - used to reset min/max temp at midnight
# https://esphome.io/components/time/index.html
#----------------------------------------------------------------------
time:
  - platform: sntp
    id: local_sntp_time
    on_time:
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              // at midnight, reset pump run time to 0
              PoolPumpRS485::instance->resetTotalPumpRunTime();
              
              // at midnight, reset min/max to current temp
              float temp = id(water_temperature)->state;
              id(minimum_water_temperature)->publish_state(temp);
              id(maximum_water_temperature)->publish_state(temp);
