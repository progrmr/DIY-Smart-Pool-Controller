substitutions:
  devicename: esphome-pool-controller
  friendly_devicename: "ESPHome Pool Controller"
  deviceip: 192.168.0.229

esphome:
  name: ${devicename}
  friendly_name: ${friendly_devicename}
  includes:
    - pool_pump_rs485.h
  on_boot:
    priority: -10
    then:
      - lambda: |-
          uint32_t notConnectedCounter = 0;
          while (!WiFi.isConnected()) {
            delay(100);   // delay 100 ms
            notConnectedCounter++;
            if(notConnectedCounter > 600) { // Reset board if not connected after 60s
              ESP.restart();
            }
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "MlixHoYywbRk7gFoWjevidw9EjKcaUDVhOz1a1xSjv0="

ota:


wifi:
  networks:
  - ssid: !secret patio_wifi_ssid
    password: !secret patio_wifi_password
  - ssid: !secret wifi_ssid
    password: !secret wifi_password

  # Optional manual IP
  manual_ip:
    static_ip: ${deviceip}
    gateway: 192.168.0.1
    subnet: 255.255.255.0

# UART is used for RS-485 serial comm with the Pentair Pool Pump
# the PoolPumpRS485 custom component class handles the actual
# sending and receiving messages via the RS-485 serial port.
uart:
  id: pump_uart_bus
  tx_pin: GPIO14
  rx_pin: GPIO27
  baud_rate: 9600

# The two relays are used to send 24 VAC power to the valve actuator:
# 1. valve_direction_relay:
#    * when ON turns the valve to send water through the solar panels,
#    * when OFF valve turns back to normal bypass solar position
# 2. valve_power_relay:
#    * when ON provide 24 VAC power to the valve actuator, valve will
#      not change direction or move at all unless this is on.
# NOTE: valve actuation takes about 26 seconds to complete, 
#       actuator current drops to 0 when it finishes moving
switch:
  - platform: gpio
    name: "Valve Direction Relay"
    id: valve_direction_relay
    inverted: True
    pin: GPIO22
    on_turn_on:
      then:
        - switch.turn_on: valve_power_relay
        - delay: 35s
        - switch.turn_off: valve_power_relay
        - switch.turn_off: valve_direction_relay

  - platform: gpio
    name: "Valve Power Relay"
    id: valve_power_relay
    inverted: True
    pin: GPIO23      
    on_turn_on:
      then:
        - lambda: |-
            auto myPoolPump = PoolPumpRS485::instance;
            myPoolPump->peakActuatorCurrent = 0;
            myPoolPump->msActuatorStartTime = 0;
        - repeat:
            count: 32
            then:
              - delay: 0.5s
              - component.update: valve_actuator_amps
              - delay: 0.5s
        - switch.turn_off: valve_power_relay
        - switch.turn_off: valve_direction_relay
        - delay: 0.5s
        - component.update: valve_actuator_amps

number:
  - platform: template
    name: "Current Limit"
    id: current_limit
    optimistic: True
    restore_value: True
    max_value: 2.0
    min_value: 0.1
    step: 0.1
    initial_value: 0.6
    ## NOT IMPLEMENTED YET ##
    # need to do something with the limit, when actual exceeds limit

  - platform: template
    name: "Pump Speed Request"
    id: pump_speed_request
    optimistic: True
    restore_value: True
    unit_of_measurement: RPM
    device_class: speed
    max_value: 4000
    min_value: 0
    step: 10
    initial_value: 0
    set_action:
      - lambda: |-
          PoolPumpRS485::instance->setPumpSpeed(lroundf(x));

sensor:
  - platform: custom
    id: pool_pump_rs485
    lambda: |-
      auto myPoolPump = new PoolPumpRS485(id(pump_uart_bus));
      PoolPumpRS485::instance = myPoolPump;   // save singleton instance
      App.register_component(myPoolPump);
      return {myPoolPump->rpmSensor, 
              myPoolPump->wattsSensor, 
              myPoolPump->peakCurrentSensor,
              myPoolPump->actuationTimeSensor}; 
    sensors:
      - name: "RPM Sensor"
        unit_of_measurement: RPM
        device_class: "speed"
        state_class: "measurement"
      - name: "Watts Sensor"
        accuracy_decimals: 0
        unit_of_measurement: W
        device_class: "power"
        state_class: "measurement"
      - name: "Peak Current"
        accuracy_decimals: 3
        unit_of_measurement: A
        device_class: "current"
        state_class: "measurement"
      - name: "Actuation Time"
        accuracy_decimals: 0
        unit_of_measurement: s
        device_class: "duration"
        state_class: "measurement"
      
# https://esphome.io/components/sensor/ntc
# Solar Panel Thermistor sensor
  - platform: ntc
    name: Panel Temperature
    id: panel_temperature
    sensor: panel_thermistor
    calibration:
      - 15310Ohm -> 16°C
      - 10000Ohm -> 25°C
      - 3602Ohm -> 50°C
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 5

# Water Temperature Thermistor sensor
  - platform: ntc
    name: Water Temperature
    id: water_temperature
    sensor: water_thermistor
    calibration:
      - 15310Ohm -> 16°C
      - 10000Ohm -> 25°C
      - 3602Ohm -> 50°C
#    filters:
#      - offset: 0.11
#      - sliding_window_moving_average:
#          window_size: 5
#          send_every: 5

# https://esphome.io/components/sensor/resistance
  - platform: resistance
    internal: True
    id: panel_thermistor
    sensor: panel_thermistor_adc
    configuration: DOWNSTREAM
    resistor: 5.6kOhm
    name: Panel Resistance Sensor
    reference_voltage: 3.3V
    
  - platform: resistance
    internal: True
    id: water_thermistor
    sensor: water_thermistor_adc
    configuration: DOWNSTREAM
    resistor: 5.6kOhm
    name: Water Resistance Sensor
    reference_voltage: 3.3V

# https://esphome.io/components/sensor/adc
  - platform: adc
    internal: True
    id: panel_thermistor_adc
    pin: GPIO33
    name: Panel Thermistor ADC
    update_interval: 30s    
    attenuation: 11db
    filters:
      - offset: -0.02

  - platform: adc
    internal: True
    id: water_thermistor_adc
    pin: GPIO32
    name: Water Thermistor ADC
    update_interval: 30s    
    attenuation: 11db
    filters:
      - offset: -0.02

# Valve Actuator Current sensor measures peak voltage across a shunt
# resistor (1 ohm) from an AC sine wave (after half wave rectifier), 
# We measure peak voltage(amps) with help of a 10uF capacitor after the
# rectifier which holds at the peak voltage.  There is a 22k resistor
# on the capacitor so that the voltage reading will decay when
# the actual current drops.
  - platform: adc
    pin: GPIO36
    name: "Valve Actuator Current"
    id: valve_actuator_amps
    unit_of_measurement: A
    accuracy_decimals: 3
    attenuation: 6db
# NOTE: update_interval of never here, but we manually update every 2-3s when
#       the actuator power is on, if power is off, current *should* be zero.
    update_interval: never    
    filters:
# NOTE: if x < 0.15 then current is really 0, it reads 0.15 because
#       the ADC has a minimum voltage that it reads and shows that value
#       even when there is no current flowing.
      - lambda: |-
          if (x < 0.15) { return 0.0; } else { return x; }     
# NOTE: multiply by 0.707 to convert peak amps reading to RMS amps value
      - multiply: 0.707
    on_value:
      - lambda: |-
          PoolPumpRS485::instance->setActuatorCurrent(x);

  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    entity_category: "diagnostic"
    update_interval: 120s
  