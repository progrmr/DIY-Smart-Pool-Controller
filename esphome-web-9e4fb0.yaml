substitutions:
  devicename: esphome-pool-controller
  friendly_devicename: "ESPHome Pool Controller"
  deviceip: 192.168.0.229

esphome:
  name: ${devicename}
  friendly_name: ${friendly_devicename}
  includes:
    - solar_controller.h
    - valve_actuator.h
    - pool_pump_rs485.h
  on_boot:
    priority: -10
    then:
      - delay: 10s
      - lambda: |-
          //---------------------
          // need to call setPumpSpeed after reboot in case we
          // are requesting a particular pump speed.  The C++ class gets
          // reinitialized when booting and we need to restore the speed.
          //---------------------
          auto rpmRequest = id(pump_speed_request);
          if (rpmRequest->state != NAN) {
            long speed = lroundf(rpmRequest->state);
            ESP_LOGD("custom","===== BOOT: restoring pump RPM request %l", speed);
            PoolPumpRS485::instance->setPumpSpeed(speed);
          }
      - delay: 5s
      - lambda: |-
          //---------------------
          // need to init various sensors, they don't get
          // restored after a reboot
          //---------------------
          ESP_LOGD("custom","===== BOOT: restoring min/max water temps, amps/peak");
          float curTemp = id(water_temperature).state;
          id(minimum_water_temperature)->publish_state(curTemp);
          id(maximum_water_temperature)->publish_state(curTemp);
          id(valve_actuator_amps)->publish_state(0);
          id(peak_current)->publish_state(0);
          id(actuation_time)->publish_state(0);
      - delay: 5s
      - lambda: |-
          uint32_t notConnectedCount = 0;
          while (!WiFi.isConnected()) {
            delay(100);   // delay 100 ms
            notConnectedCount++;
            if (notConnectedCount > 300) {   // reset board if not connected after 30s
              ESP.restart();
            }
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "MlixHoYywbRk7gFoWjevidw9EjKcaUDVhOz1a1xSjv0="

ota:

wifi:
  networks:
  - ssid: !secret wifi_ssid
    password: !secret wifi_password

  # Optional manual IP
  manual_ip:
    static_ip: ${deviceip}
    gateway: 192.168.0.1
    subnet: 255.255.255.0

# https://esphome.io/components/time/index.html
time:
  - platform: sntp
    on_time_sync: 
      then:
        - logger.log: "Pool Controller Time Synced"
    on_time:
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              // at midnight, reset min/max to current temp
              float temp = id(water_temperature)->state;
              id(minimum_water_temperature)->publish_state(temp);
              id(maximum_water_temperature)->publish_state(temp);

# UART is used for RS-485 serial comm with the Pentair Pool Pump
# the PoolPumpRS485 custom component class handles the actual
# sending and receiving messages via the RS-485 serial port.
uart:
  id: pump_uart_bus
  tx_pin: GPIO14
  rx_pin: GPIO27
  baud_rate: 9600

# The two relays are used to send 24 VAC power to the valve actuator:
# 1. valve_direction_relay:
#    * when ON turns the valve to send water through the solar panels,
#    * when OFF valve turns back to normal (bypass solar) position
# 2. valve_power_relay:
#    * when ON provide 24 VAC power to the valve actuator, valve will
#      not change direction or move at all unless this is on.
# NOTE: valve actuation takes about 26 seconds to complete, 
#       actuator current drops to 0 when it finishes moving
switch:
  - platform: gpio
    name: "Valve Direction Relay"
    id: valve_direction_relay
    inverted: True
    pin: GPIO22
    on_turn_on:
      then:
        - lambda: |-
            ValvePosition::instance->setValveDirectionRelayOn(true);
        - switch.turn_on: valve_power_relay
        - delay: 30s
        - switch.turn_off: valve_power_relay
        - switch.turn_off: valve_direction_relay
    on_turn_off:
      then:
        - lambda: |-
            ValvePosition::instance->setValveDirectionRelayOn(false);
        
  - platform: gpio
    name: "Valve Power Relay"
    id: valve_power_relay
    inverted: True
    pin: GPIO23  
    on_turn_on:
      then:
        - lambda: |-
            ValvePosition::instance->setValvePowerRelayOn(true);
        - repeat:
            count: 32
            then:
              - delay: 0.5s
              - component.update: valve_actuator_amps
              - delay: 0.5s
        - switch.turn_off: valve_power_relay
    on_turn_off:
      then:
        - lambda: |-
            ValvePosition::instance->setValvePowerRelayOn(false);

number:
# Current Limit is used to detect problems with the valve actuator.  When
# actual current exceeds this limit we should turn it off and report an fault.
  - platform: template
    name: "Current Limit"
    id: current_limit
    optimistic: True
    restore_value: True
    max_value: 2.0
    min_value: 0.1
    step: 0.1
    initial_value: 0.6
    device_class: "current"
    ## NOT IMPLEMENTED YET ##
    # need to do something with the limit, when actual exceeds limit

# Pump Speed Request is a temporary solution to commanding the pump to a particular
# RPM when the solar valve is on, the higher RPM is needed to efficiently circulate
# water through the solar panels on the roof.
  - platform: template
    name: "Pump Speed Request"
    id: pump_speed_request
    optimistic: True
    restore_value: True
    unit_of_measurement: RPM
    device_class: speed
    mode: box
    max_value: 4000
    min_value: 0
    step: 10
    initial_value: 0
    set_action:
      - lambda: |-
          PoolPumpRS485::instance->setPumpSpeed(lroundf(x));

  - platform: template
    name: "Pool Target Temperature"
    id: pool_target_temp
    optimistic: True
    restore_value: True
    unit_of_measurement: "°F"
    device_class: temperature
    mode: box
    min_value: 50
    max_value: 105
    step: 1
    initial_value: 86.6

text_sensor:
  # Valve Position can be:  unknown, opening, closing, opened, closed
  # It is initially unknown, but changes based on the relay states etc.
  # It is set inside the ValvePosition class.
  - platform: custom
    lambda: |-
      auto vp = new ValvePosition();
      ValvePosition::instance = vp;
      App.register_component(vp);
      return {vp};
    text_sensors:
      name: "Valve Position"  
      id: valve_position
      on_value:
        then:
          - if:
              condition:
                or:
                  - text_sensor.state:
                      id: valve_position
                      state: "opened"
                  - text_sensor.state:
                      id: valve_position
                      state: "opening"
              then:
                - lambda: 'SolarController::instance->recordValvePositionChangeTime();'
                - number.set:
                    id: pump_speed_request
                    value: 2701
          - if:
              condition:
                or:
                  - text_sensor.state:
                      id: valve_position
                      state: "closed"
                  - text_sensor.state:
                      id: valve_position
                      state: "closing"
              then:
                - lambda: 'SolarController::instance->recordValvePositionChangeTime();'
                - number.set:
                    id: pump_speed_request
                    value: 2401
                - delay: 60s
                - number.set: 
                    id: pump_speed_request
                    value: 111

binary_sensor:
  - platform: custom
    lambda: |-
      auto sc = new SolarController();
      SolarController::instance = sc;
      App.register_component(sc);
      return {sc};
    binary_sensors:
      - name: "Use Solar Heat"
        id: use_solar_heat
        on_press:
          lambda: 'ESP_LOGD("custom","----- Use Solar Heat in ON");'
        on_release:
          lambda: 'ESP_LOGD("custom","----- Use Solar Heat in OFF");'

sensor:
  # Peak Current keeps track of the valve actuator's peak currant usage.   
  # This is for future diagnostic purposes and problem solving.
  - platform: custom
    lambda: |-
      auto pc = new PeakCurrent();
      PeakCurrent::instance = pc;
      App.register_component(pc);
      return {pc};
    sensors:
      - name: "Peak Current"
        id: peak_current
        accuracy_decimals: 3
        unit_of_measurement: A
        device_class: "current"
        state_class: "measurement"

  # Actuator Time measures how long it takes for the valve actuator to complete
  # its actuation from open to closed or closed to open.  This is for future diagnostics.
  - platform: custom
    lambda: |-
      auto at = new ActuationTime();
      ActuationTime::instance = at;
      App.register_component(at);
      return {at};
    sensors:
      - name: "Actuation Time"
        id: actuation_time
        accuracy_decimals: 1
        unit_of_measurement: s
        device_class: "duration"
        state_class: "measurement"

  # Pool Pump RS485 handles serial communications with the pump.  Getting the pump status
  # and telling the pump when to speed up or slow down for solar heating.  Pump status 
  # messages have RPM and Wattage usage which appear in sensors here.  RPM is used to
  # determine when the pump is actually running.  Wattage is for diagnostic/info only.
  - platform: custom
    lambda: |-
      auto myPoolPump = new PoolPumpRS485(id(pump_uart_bus));
      PoolPumpRS485::instance = myPoolPump;   // save singleton instance
      App.register_component(myPoolPump);
      return {myPoolPump->rpmSensor, 
              myPoolPump->wattsSensor}; 
    sensors:
      - name: "RPM Sensor"
        id: pump_rpm_sensor
        unit_of_measurement: RPM
        device_class: "speed"
        state_class: "measurement"
      - name: "Watts Sensor"
        id: pump_watts_sensor
        accuracy_decimals: 0
        unit_of_measurement: W
        device_class: "power"
        state_class: "measurement"

# https://esphome.io/components/sensor/ntc
# Solar Panel Thermistor sensor - this thermistor is located on the roof solar panels and
# is used to determine if there is enough sun/heat to heat the pool water.
  - platform: ntc
    name: Panel Temperature
    id: panel_temperature
    sensor: panel_thermistor
    calibration:
      - 15310Ohm -> 16°C
      - 10000Ohm -> 25°C
      - 3602Ohm -> 50°C
    filters:
      - offset: 0.6
      - sliding_window_moving_average:
          window_size: 5
          send_every: 5

# Water Temp Daily Minimum/Maximum sensor
# https://esphome.io/components/sensor/template.html
  - platform: template
    name: Minimum Water Temperature
    id: minimum_water_temperature
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    # NOTE: updates are done elsewhere:
    # (1) midnight (resets min from current) in the time sntp above, 
    # (2) whenever the water_temperature sensor below updates.
    update_interval: never

  - platform: template
    name: Maximum Water Temperature
    id: maximum_water_temperature
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    # NOTE: updates are done elsewhere:
    # (1) midnight (resets min from current) in the time sntp above, 
    # (2) whenever the water_temperature sensor below updates.
    update_interval: never

# Water Temperature Thermistor sensor is located in a pipe right next to the pump
# output and it used to measure pool water temperature.  This temperature reading
# is NOT valid if the pump is off since water is not flowing through the pipe then.
# This temperature is used to update the min/max temperatures above.
  - platform: ntc
    name: Water Temperature
    id: water_temperature
    sensor: water_thermistor
    calibration:
      - 15310Ohm -> 16°C
      - 10000Ohm -> 25°C
      - 3602Ohm -> 50°C
    on_value:
      lambda: |-
        auto minTemp = id(minimum_water_temperature);
        if (x < minTemp->state || minTemp->state == NAN) {
          minTemp->publish_state(x);
        }
        auto maxTemp = id(maximum_water_temperature);
        if (x > maxTemp->state || minTemp->state == NAN) {
          maxTemp->publish_state(x);
        }
    filters:
      - offset: 0.11
      - sliding_window_moving_average:
          window_size: 5
          send_every: 5

# https://esphome.io/components/sensor/resistance
  - platform: resistance
    internal: True
    id: panel_thermistor
    sensor: panel_thermistor_adc
    configuration: DOWNSTREAM
    resistor: 5.6kOhm
    name: Panel Resistance Sensor
    reference_voltage: 3.3V
    
  - platform: resistance
    internal: True
    id: water_thermistor
    sensor: water_thermistor_adc
    configuration: DOWNSTREAM
    resistor: 5.6kOhm
    name: Water Resistance Sensor
    reference_voltage: 3.3V

# https://esphome.io/components/sensor/adc
  - platform: adc
    internal: True
    id: panel_thermistor_adc
    pin: GPIO33
    name: Panel Thermistor ADC
    update_interval: 31s    
    attenuation: 11db
    filters:
      - offset: -0.02

  - platform: adc
    internal: True
    id: water_thermistor_adc
    pin: GPIO32
    name: Water Thermistor ADC
    update_interval: 30s    
    attenuation: 11db
    filters:
      - offset: -0.02

# Valve Actuator Current sensor measures peak voltage across a shunt
# resistor (1 ohm) from an AC sine wave (after half wave rectifier), 
# We measure peak voltage(amps) with help of a 10uF capacitor after the
# rectifier which holds at the peak voltage.  There is a 22k resistor
# on the capacitor so that the voltage reading will decay when
# the actual current drops.
  - platform: adc
    pin: GPIO36
    name: "Valve Actuator Current"
    id: valve_actuator_amps
    unit_of_measurement: A
    accuracy_decimals: 3
    attenuation: 6db
# NOTE: update_interval of never here, but we manually update every 2-3s when
#       the actuator power is on, if power is off, current *should* be zero.
    update_interval: never  
    filters:
      - lambda: |-
          // if x < 0.15 then current is really 0, it reads 0.15 because
          // the ADC has a minimum voltage that it reads and shows that value
          // even when there is no current flowing (and actual voltage is 0)
          if (x < 0.15) { return 0.0; } else { return x; }     
# NOTE: multiply by 0.707 to convert peak amps reading to RMS amps value
      - multiply: 0.707
    on_value:
      - lambda: |-
          ValvePosition::instance->setCurrent(x);

  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    entity_category: "diagnostic"
    update_interval: 120s
  